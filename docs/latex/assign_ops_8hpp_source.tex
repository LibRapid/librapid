\hypertarget{assign_ops_8hpp_source}{}\doxysection{assign\+Ops.\+hpp}
\label{assign_ops_8hpp_source}\index{librapid/include/librapid/array/assignOps.hpp@{librapid/include/librapid/array/assignOps.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#ifndef LIBRAPID\_ARRAY\_ASSIGN\_OPS\_HPP}}
\DoxyCodeLine{2 \textcolor{preprocessor}{\#define LIBRAPID\_ARRAY\_ASSIGN\_OPS\_HPP}}
\DoxyCodeLine{3 }
\DoxyCodeLine{4 \textcolor{keyword}{namespace }librapid::detail \{}
\DoxyCodeLine{5     \textcolor{comment}{// All assignment operators are forward declared in "{}forward.hpp"{} so they can be used}}
\DoxyCodeLine{6     \textcolor{comment}{// elsewhere. They are defined here.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{16     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ShapeType\_, \textcolor{keyword}{typename} StorageType\_, \textcolor{keyword}{typename} Functor\_, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{17     LIBRAPID\_ALWAYS\_INLINE \textcolor{keywordtype}{void}}
\DoxyCodeLine{18     assign(ArrayContainer<ShapeType\_, StorageType\_> \&lhs,}
\DoxyCodeLine{19            \textcolor{keyword}{const} detail::Function<Descriptor::Trivial, Functor\_, Args...> \&function) \{}
\DoxyCodeLine{20         \textcolor{keyword}{using} Scalar                  = \textcolor{keyword}{typename} ArrayContainer<ShapeType\_, StorageType\_>::Scalar;}
\DoxyCodeLine{21         \textcolor{keyword}{constexpr} int64\_t packetWidth = typetraits::TypeInfo<Scalar>::packetWidth;}
\DoxyCodeLine{22 }
\DoxyCodeLine{23         \textcolor{keyword}{const} int64\_t size       = function.shape().size();}
\DoxyCodeLine{24         \textcolor{keyword}{const} int64\_t vectorSize = size -\/ (size \% packetWidth);}
\DoxyCodeLine{25 }
\DoxyCodeLine{26         \textcolor{comment}{// Ensure the function can actually be assigned to the array container}}
\DoxyCodeLine{27         \textcolor{keyword}{static\_assert}(typetraits::IsSame<Scalar, \textcolor{keyword}{typename} std::decay\_t<\textcolor{keyword}{decltype}(function)>::Scalar>,}
\DoxyCodeLine{28                       \textcolor{stringliteral}{"{}Function return type must be the same as the array container's scalar type"{}});}
\DoxyCodeLine{29         LIBRAPID\_ASSERT(lhs.shape() == function.shape(), \textcolor{stringliteral}{"{}Shapes must be equal"{}});}
\DoxyCodeLine{30 }
\DoxyCodeLine{31         \textcolor{keywordflow}{for} (int64\_t index = 0; index < vectorSize; index += packetWidth) \{}
\DoxyCodeLine{32             lhs.writePacket(index, function.packet(index));}
\DoxyCodeLine{33         \}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35         \textcolor{comment}{// Assign the remaining elements}}
\DoxyCodeLine{36         \textcolor{keywordflow}{for} (int64\_t index = vectorSize; index < size; ++index) \{}
\DoxyCodeLine{37             lhs.write(index, function.scalar(index));}
\DoxyCodeLine{38         \}}
\DoxyCodeLine{39     \}}
\DoxyCodeLine{40 }
\DoxyCodeLine{41     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ShapeType\_, \textcolor{keyword}{typename} StorageType\_, \textcolor{keyword}{typename} Functor\_, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{42     LIBRAPID\_ALWAYS\_INLINE \textcolor{keywordtype}{void}}
\DoxyCodeLine{43     assignParallel(ArrayContainer<ShapeType\_, StorageType\_> \&lhs,}
\DoxyCodeLine{44                    \textcolor{keyword}{const} detail::Function<Descriptor::Trivial, Functor\_, Args...> \&function) \{}
\DoxyCodeLine{45         \textcolor{keyword}{using} Scalar                  = \textcolor{keyword}{typename} ArrayContainer<ShapeType\_, StorageType\_>::Scalar;}
\DoxyCodeLine{46         \textcolor{keyword}{constexpr} int64\_t packetWidth = typetraits::TypeInfo<Scalar>::packetWidth;}
\DoxyCodeLine{47 }
\DoxyCodeLine{48         \textcolor{keyword}{const} int64\_t size       = function.shape().size();}
\DoxyCodeLine{49         \textcolor{keyword}{const} int64\_t vectorSize = size -\/ (size \% packetWidth);}
\DoxyCodeLine{50 }
\DoxyCodeLine{51         \textcolor{comment}{// Ensure the function can actually be assigned to the array container}}
\DoxyCodeLine{52         \textcolor{keyword}{static\_assert}(typetraits::IsSame<Scalar, \textcolor{keyword}{typename} std::decay\_t<\textcolor{keyword}{decltype}(function)>::Scalar>,}
\DoxyCodeLine{53                       \textcolor{stringliteral}{"{}Function return type must be the same as the array container's scalar type"{}});}
\DoxyCodeLine{54         LIBRAPID\_ASSERT(lhs.shape() == function.shape(), \textcolor{stringliteral}{"{}Shapes must be equal"{}});}
\DoxyCodeLine{55 }
\DoxyCodeLine{56 \textcolor{preprocessor}{\#pragma omp parallel for shared(vectorSize, lhs, function) default(none)                           \(\backslash\)}}
\DoxyCodeLine{57 \textcolor{preprocessor}{  num\_threads(global::numThreads)}}
\DoxyCodeLine{58         \textcolor{keywordflow}{for} (int64\_t index = 0; index < vectorSize; index += packetWidth) \{}
\DoxyCodeLine{59             lhs.writePacket(index, function.packet(index));}
\DoxyCodeLine{60         \}}
\DoxyCodeLine{61 }
\DoxyCodeLine{62         \textcolor{comment}{// Assign the remaining elements}}
\DoxyCodeLine{63         \textcolor{keywordflow}{for} (int64\_t index = vectorSize; index < size; ++index) \{}
\DoxyCodeLine{64             lhs.write(index, function.scalar(index));}
\DoxyCodeLine{65         \}}
\DoxyCodeLine{66     \}}
\DoxyCodeLine{67 \} \textcolor{comment}{// namespace librapid::detail}}
\DoxyCodeLine{68 }
\DoxyCodeLine{69 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// LIBRAPID\_ARRAY\_ASSIGN\_OPS\_HPP}}

\end{DoxyCode}
