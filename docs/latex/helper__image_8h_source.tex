\hypertarget{helper__image_8h_source}{}\doxysection{helper\+\_\+image.\+h}
\label{helper__image_8h_source}\index{librapid/include/librapid/cuda/helper\_image.h@{librapid/include/librapid/cuda/helper\_image.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/* Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.}}
\DoxyCodeLine{2 \textcolor{comment}{ *}}
\DoxyCodeLine{3 \textcolor{comment}{ * Redistribution and use in source and binary forms, with or without}}
\DoxyCodeLine{4 \textcolor{comment}{ * modification, are permitted provided that the following conditions}}
\DoxyCodeLine{5 \textcolor{comment}{ * are met:}}
\DoxyCodeLine{6 \textcolor{comment}{ *  * Redistributions of source code must retain the above copyright}}
\DoxyCodeLine{7 \textcolor{comment}{ *    notice, this list of conditions and the following disclaimer.}}
\DoxyCodeLine{8 \textcolor{comment}{ *  * Redistributions in binary form must reproduce the above copyright}}
\DoxyCodeLine{9 \textcolor{comment}{ *    notice, this list of conditions and the following disclaimer in the}}
\DoxyCodeLine{10 \textcolor{comment}{ *    documentation and/or other materials provided with the distribution.}}
\DoxyCodeLine{11 \textcolor{comment}{ *  * Neither the name of NVIDIA CORPORATION nor the names of its}}
\DoxyCodeLine{12 \textcolor{comment}{ *    contributors may be used to endorse or promote products derived}}
\DoxyCodeLine{13 \textcolor{comment}{ *    from this software without specific prior written permission.}}
\DoxyCodeLine{14 \textcolor{comment}{ *}}
\DoxyCodeLine{15 \textcolor{comment}{ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY}}
\DoxyCodeLine{16 \textcolor{comment}{ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE}}
\DoxyCodeLine{17 \textcolor{comment}{ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR}}
\DoxyCodeLine{18 \textcolor{comment}{ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR}}
\DoxyCodeLine{19 \textcolor{comment}{ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,}}
\DoxyCodeLine{20 \textcolor{comment}{ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,}}
\DoxyCodeLine{21 \textcolor{comment}{ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR}}
\DoxyCodeLine{22 \textcolor{comment}{ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY}}
\DoxyCodeLine{23 \textcolor{comment}{ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT}}
\DoxyCodeLine{24 \textcolor{comment}{ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE}}
\DoxyCodeLine{25 \textcolor{comment}{ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.}}
\DoxyCodeLine{26 \textcolor{comment}{ */}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{comment}{// These are helper functions for the SDK samples (image,bitmap)}}
\DoxyCodeLine{29 \textcolor{preprocessor}{\#ifndef COMMON\_HELPER\_IMAGE\_H\_}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#define COMMON\_HELPER\_IMAGE\_H\_}}
\DoxyCodeLine{31 }
\DoxyCodeLine{32 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#include <assert.h>}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#include "{}exception.h"{}}}
\DoxyCodeLine{35 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{36 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#include <math.h>}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#include <stdint.h>}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 \textcolor{preprocessor}{\#ifndef MIN}}
\DoxyCodeLine{43 \textcolor{preprocessor}{\#   define MIN(a, b) ((a < b) ? a : b)}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#ifndef MAX}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#   define MAX(a, b) ((a > b) ? a : b)}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{48 }
\DoxyCodeLine{49 \textcolor{preprocessor}{\#ifndef EXIT\_WAIVED}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#   define EXIT\_WAIVED 2}}
\DoxyCodeLine{51 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{52 }
\DoxyCodeLine{53 \textcolor{preprocessor}{\#include "{}helper\_string.h"{}}}
\DoxyCodeLine{54 }
\DoxyCodeLine{55 \textcolor{comment}{// namespace unnamed (internal)}}
\DoxyCodeLine{56 \textcolor{keyword}{namespace }helper\_image\_internal \{}
\DoxyCodeLine{58     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} PGMHeaderSize = 0x40;}
\DoxyCodeLine{59 }
\DoxyCodeLine{60     \textcolor{comment}{// types}}
\DoxyCodeLine{61 }
\DoxyCodeLine{63     \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{64     \textcolor{keyword}{struct }\mbox{\hyperlink{structhelper__image__internal_1_1_converter_from_u_byte}{ConverterFromUByte}};}
\DoxyCodeLine{65 }
\DoxyCodeLine{67     \textcolor{keyword}{template}<>}
\DoxyCodeLine{68     \textcolor{keyword}{struct }\mbox{\hyperlink{structhelper__image__internal_1_1_converter_from_u_byte}{ConverterFromUByte}}<unsigned char> \{}
\DoxyCodeLine{72         \textcolor{keywordtype}{float} \mbox{\hyperlink{structhelper__image__internal_1_1_converter_from_u_byte_3_01unsigned_01char_01_4_a33efe59a6e9dfbef50619da68c46eb4d}{operator()}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \&val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(val); \}}
\DoxyCodeLine{73     \};}
\DoxyCodeLine{74 }
\DoxyCodeLine{76     \textcolor{keyword}{template}<>}
\DoxyCodeLine{77     \textcolor{keyword}{struct }\mbox{\hyperlink{structhelper__image__internal_1_1_converter_from_u_byte}{ConverterFromUByte}}<float> \{}
\DoxyCodeLine{81         \textcolor{keywordtype}{float} \mbox{\hyperlink{structhelper__image__internal_1_1_converter_from_u_byte_3_01float_01_4_a8e53bbf24b7d444607972b90861fec69}{operator()}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \&val) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(val) / 255.0f; \}}
\DoxyCodeLine{82     \};}
\DoxyCodeLine{83 }
\DoxyCodeLine{85     \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{86     \textcolor{keyword}{struct }\mbox{\hyperlink{structhelper__image__internal_1_1_converter_to_u_byte}{ConverterToUByte}};}
\DoxyCodeLine{87 }
\DoxyCodeLine{89     \textcolor{keyword}{template}<>}
\DoxyCodeLine{90     \textcolor{keyword}{struct }\mbox{\hyperlink{structhelper__image__internal_1_1_converter_to_u_byte}{ConverterToUByte}}<unsigned char> \{}
\DoxyCodeLine{94         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \mbox{\hyperlink{structhelper__image__internal_1_1_converter_to_u_byte_3_01unsigned_01char_01_4_afe997e2564da5320fc96b908c7132e6e}{operator()}}(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \&val) \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{95     \};}
\DoxyCodeLine{96 }
\DoxyCodeLine{98     \textcolor{keyword}{template}<>}
\DoxyCodeLine{99     \textcolor{keyword}{struct }\mbox{\hyperlink{structhelper__image__internal_1_1_converter_to_u_byte}{ConverterToUByte}}<float> \{}
\DoxyCodeLine{103         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \mbox{\hyperlink{structhelper__image__internal_1_1_converter_to_u_byte_3_01float_01_4_aedc92d68abeb24777e5590e010eb94da}{operator()}}(\textcolor{keyword}{const} \textcolor{keywordtype}{float} \&val) \{}
\DoxyCodeLine{104             \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(val * 255.0f);}
\DoxyCodeLine{105         \}}
\DoxyCodeLine{106     \};}
\DoxyCodeLine{107 \} \textcolor{comment}{// namespace helper\_image\_internal}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{preprocessor}{\#if defined(WIN32) || defined(\_WIN32) || defined(WIN64) || defined(\_WIN64)}}
\DoxyCodeLine{110 \textcolor{preprocessor}{\#   ifndef FOPEN}}
\DoxyCodeLine{111 \textcolor{preprocessor}{\#       define FOPEN(fHandle, filename, mode) fopen\_s(\&fHandle, filename, mode)}}
\DoxyCodeLine{112 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{113 \textcolor{preprocessor}{\#   ifndef FOPEN\_FAIL}}
\DoxyCodeLine{114 \textcolor{preprocessor}{\#       define FOPEN\_FAIL(result) (result != 0)}}
\DoxyCodeLine{115 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{116 \textcolor{preprocessor}{\#   ifndef SSCANF}}
\DoxyCodeLine{117 \textcolor{preprocessor}{\#       define SSCANF sscanf\_s}}
\DoxyCodeLine{118 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{119 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{120 \textcolor{preprocessor}{\#   ifndef FOPEN}}
\DoxyCodeLine{121 \textcolor{preprocessor}{\#       define FOPEN(fHandle, filename, mode) (fHandle = fopen(filename, mode))}}
\DoxyCodeLine{122 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{123 \textcolor{preprocessor}{\#   ifndef FOPEN\_FAIL}}
\DoxyCodeLine{124 \textcolor{preprocessor}{\#       define FOPEN\_FAIL(result) (result == NULL)}}
\DoxyCodeLine{125 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{126 \textcolor{preprocessor}{\#   ifndef SSCANF}}
\DoxyCodeLine{127 \textcolor{preprocessor}{\#       define SSCANF sscanf}}
\DoxyCodeLine{128 \textcolor{preprocessor}{\#   endif}}
\DoxyCodeLine{129 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{130 }
\DoxyCodeLine{131 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_\_loadPPM(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *h,}
\DoxyCodeLine{132                       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *channels) \{}
\DoxyCodeLine{133     FILE *fp = NULL;}
\DoxyCodeLine{134 }
\DoxyCodeLine{135     \textcolor{keywordflow}{if} (FOPEN\_FAIL(FOPEN(fp, file, \textcolor{stringliteral}{"{}rb"{}}))) \{}
\DoxyCodeLine{136         std::cerr << \textcolor{stringliteral}{"{}\_\_LoadPPM() : Failed to open file: "{}} << file << std::endl;}
\DoxyCodeLine{137         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{138     \}}
\DoxyCodeLine{139 }
\DoxyCodeLine{140     \textcolor{comment}{// check header}}
\DoxyCodeLine{141     \textcolor{keywordtype}{char} header[helper\_image\_internal::PGMHeaderSize];}
\DoxyCodeLine{142 }
\DoxyCodeLine{143     \textcolor{keywordflow}{if} (fgets(header, helper\_image\_internal::PGMHeaderSize, fp) == NULL) \{}
\DoxyCodeLine{144         std::cerr << \textcolor{stringliteral}{"{}\_\_LoadPPM() : reading PGM header returned NULL"{}} << std::endl;}
\DoxyCodeLine{145         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{146     \}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148     \textcolor{keywordflow}{if} (strncmp(header, \textcolor{stringliteral}{"{}P5"{}}, 2) == 0) \{}
\DoxyCodeLine{149         *channels = 1;}
\DoxyCodeLine{150     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (strncmp(header, \textcolor{stringliteral}{"{}P6"{}}, 2) == 0) \{}
\DoxyCodeLine{151         *channels = 3;}
\DoxyCodeLine{152     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{153         std::cerr << \textcolor{stringliteral}{"{}\_\_LoadPPM() : File is not a PPM or PGM image"{}} << std::endl;}
\DoxyCodeLine{154         *channels = 0;}
\DoxyCodeLine{155         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{156     \}}
\DoxyCodeLine{157 }
\DoxyCodeLine{158     \textcolor{comment}{// parse header, read maxval, width and height}}
\DoxyCodeLine{159     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} width  = 0;}
\DoxyCodeLine{160     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} height = 0;}
\DoxyCodeLine{161     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} maxval = 0;}
\DoxyCodeLine{162     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i      = 0;}
\DoxyCodeLine{163 }
\DoxyCodeLine{164     \textcolor{keywordflow}{while} (i < 3) \{}
\DoxyCodeLine{165         \textcolor{keywordflow}{if} (fgets(header, helper\_image\_internal::PGMHeaderSize, fp) == NULL) \{}
\DoxyCodeLine{166             std::cerr << \textcolor{stringliteral}{"{}\_\_LoadPPM() : reading PGM header returned NULL"{}} << std::endl;}
\DoxyCodeLine{167             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{168         \}}
\DoxyCodeLine{169 }
\DoxyCodeLine{170         \textcolor{keywordflow}{if} (header[0] == \textcolor{charliteral}{'\#'}) \{ \textcolor{keywordflow}{continue}; \}}
\DoxyCodeLine{171 }
\DoxyCodeLine{172         \textcolor{keywordflow}{if} (i == 0) \{}
\DoxyCodeLine{173             i += SSCANF(header, \textcolor{stringliteral}{"{}\%u \%u \%u"{}}, \&width, \&height, \&maxval);}
\DoxyCodeLine{174         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i == 1) \{}
\DoxyCodeLine{175             i += SSCANF(header, \textcolor{stringliteral}{"{}\%u \%u"{}}, \&height, \&maxval);}
\DoxyCodeLine{176         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i == 2) \{}
\DoxyCodeLine{177             i += SSCANF(header, \textcolor{stringliteral}{"{}\%u"{}}, \&maxval);}
\DoxyCodeLine{178         \}}
\DoxyCodeLine{179     \}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181     \textcolor{comment}{// check if given handle for the data is initialized}}
\DoxyCodeLine{182     \textcolor{keywordflow}{if} (NULL != *data) \{}
\DoxyCodeLine{183         \textcolor{keywordflow}{if} (*w != width || *h != height) \{}
\DoxyCodeLine{184             std::cerr << \textcolor{stringliteral}{"{}\_\_LoadPPM() : Invalid image dimensions."{}} << std::endl;}
\DoxyCodeLine{185         \}}
\DoxyCodeLine{186     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{187         *data = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}) * width * height * *channels);}
\DoxyCodeLine{188         *w    = width;}
\DoxyCodeLine{189         *h    = height;}
\DoxyCodeLine{190     \}}
\DoxyCodeLine{191 }
\DoxyCodeLine{192     \textcolor{comment}{// read and close file}}
\DoxyCodeLine{193     \textcolor{keywordflow}{if} (fread(*data, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}), width * height * *channels, fp) == 0) \{}
\DoxyCodeLine{194         std::cerr << \textcolor{stringliteral}{"{}\_\_LoadPPM() read data returned error."{}} << std::endl;}
\DoxyCodeLine{195     \}}
\DoxyCodeLine{196 }
\DoxyCodeLine{197     fclose(fp);}
\DoxyCodeLine{198 }
\DoxyCodeLine{199     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{200 \}}
\DoxyCodeLine{201 }
\DoxyCodeLine{202 \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{203 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkLoadPGM(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, T **data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *h) \{}
\DoxyCodeLine{204     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *idata = NULL;}
\DoxyCodeLine{205     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} channels;}
\DoxyCodeLine{206 }
\DoxyCodeLine{207     \textcolor{keywordflow}{if} (\textcolor{keyword}{true} != \_\_loadPPM(file, \&idata, w, h, \&channels)) \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{208 }
\DoxyCodeLine{209     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} size = *w * *h * channels;}
\DoxyCodeLine{210 }
\DoxyCodeLine{211     \textcolor{comment}{// initialize mem if necessary}}
\DoxyCodeLine{212     \textcolor{comment}{// the correct size is checked / set in loadPGMc()}}
\DoxyCodeLine{213     \textcolor{keywordflow}{if} (NULL == *data) \{ *data = \textcolor{keyword}{reinterpret\_cast<}T *\textcolor{keyword}{>}(malloc(\textcolor{keyword}{sizeof}(T) * size)); \}}
\DoxyCodeLine{214 }
\DoxyCodeLine{215     \textcolor{comment}{// copy and cast data}}
\DoxyCodeLine{216     std::transform(idata, idata + size, *data, \mbox{\hyperlink{structhelper__image__internal_1_1_converter_from_u_byte}{helper\_image\_internal::ConverterFromUByte<T>}}());}
\DoxyCodeLine{217 }
\DoxyCodeLine{218     free(idata);}
\DoxyCodeLine{219 }
\DoxyCodeLine{220     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{221 \}}
\DoxyCodeLine{222 }
\DoxyCodeLine{223 \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{224 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkLoadPPM4(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, T **data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *h) \{}
\DoxyCodeLine{225     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *idata = 0;}
\DoxyCodeLine{226     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} channels;}
\DoxyCodeLine{227 }
\DoxyCodeLine{228     \textcolor{keywordflow}{if} (\_\_loadPPM(file, \&idata, w, h, \&channels)) \{}
\DoxyCodeLine{229         \textcolor{comment}{// pad 4th component}}
\DoxyCodeLine{230         \textcolor{keywordtype}{int} size = *w * *h;}
\DoxyCodeLine{231         \textcolor{comment}{// keep the original pointer}}
\DoxyCodeLine{232         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *idata\_orig = idata;}
\DoxyCodeLine{233         *data                     = \textcolor{keyword}{reinterpret\_cast<}T *\textcolor{keyword}{>}(malloc(\textcolor{keyword}{sizeof}(T) * size * 4));}
\DoxyCodeLine{234         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ptr        = *data;}
\DoxyCodeLine{235 }
\DoxyCodeLine{236         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < size; i++) \{}
\DoxyCodeLine{237             *ptr++ = *idata++;}
\DoxyCodeLine{238             *ptr++ = *idata++;}
\DoxyCodeLine{239             *ptr++ = *idata++;}
\DoxyCodeLine{240             *ptr++ = 0;}
\DoxyCodeLine{241         \}}
\DoxyCodeLine{242 }
\DoxyCodeLine{243         free(idata\_orig);}
\DoxyCodeLine{244         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{245     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{246         free(idata);}
\DoxyCodeLine{247         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{248     \}}
\DoxyCodeLine{249 \}}
\DoxyCodeLine{250 }
\DoxyCodeLine{251 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \_\_savePPM(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h,}
\DoxyCodeLine{252                       \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} channels) \{}
\DoxyCodeLine{253     assert(NULL != data);}
\DoxyCodeLine{254     assert(w > 0);}
\DoxyCodeLine{255     assert(h > 0);}
\DoxyCodeLine{256 }
\DoxyCodeLine{257     std::fstream fh(file, std::fstream::out | std::fstream::binary);}
\DoxyCodeLine{258 }
\DoxyCodeLine{259     \textcolor{keywordflow}{if} (fh.bad()) \{}
\DoxyCodeLine{260         std::cerr << \textcolor{stringliteral}{"{}\_\_savePPM() : Opening file failed."{}} << std::endl;}
\DoxyCodeLine{261         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{262     \}}
\DoxyCodeLine{263 }
\DoxyCodeLine{264     \textcolor{keywordflow}{if} (channels == 1) \{}
\DoxyCodeLine{265         fh << \textcolor{stringliteral}{"{}P5\(\backslash\)n"{}};}
\DoxyCodeLine{266     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (channels == 3) \{}
\DoxyCodeLine{267         fh << \textcolor{stringliteral}{"{}P6\(\backslash\)n"{}};}
\DoxyCodeLine{268     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{269         std::cerr << \textcolor{stringliteral}{"{}\_\_savePPM() : Invalid number of channels."{}} << std::endl;}
\DoxyCodeLine{270         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{271     \}}
\DoxyCodeLine{272 }
\DoxyCodeLine{273     fh << w << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << h << \textcolor{stringliteral}{"{}\(\backslash\)n"{}} << 0xff << std::endl;}
\DoxyCodeLine{274 }
\DoxyCodeLine{275     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; (i < (w * h * channels)) \&\& fh.good(); ++i) \{ fh << data[i]; \}}
\DoxyCodeLine{276 }
\DoxyCodeLine{277     fh.flush();}
\DoxyCodeLine{278 }
\DoxyCodeLine{279     \textcolor{keywordflow}{if} (fh.bad()) \{}
\DoxyCodeLine{280         std::cerr << \textcolor{stringliteral}{"{}\_\_savePPM() : Writing data failed."{}} << std::endl;}
\DoxyCodeLine{281         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{282     \}}
\DoxyCodeLine{283 }
\DoxyCodeLine{284     fh.close();}
\DoxyCodeLine{285 }
\DoxyCodeLine{286     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{287 \}}
\DoxyCodeLine{288 }
\DoxyCodeLine{289 \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{290 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkSavePGM(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, T *data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h) \{}
\DoxyCodeLine{291     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} size    = w * h;}
\DoxyCodeLine{292     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *idata = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}) * size);}
\DoxyCodeLine{293 }
\DoxyCodeLine{294     std::transform(data, data + size, idata, \mbox{\hyperlink{structhelper__image__internal_1_1_converter_to_u_byte}{helper\_image\_internal::ConverterToUByte<T>}}());}
\DoxyCodeLine{295 }
\DoxyCodeLine{296     \textcolor{comment}{// write file}}
\DoxyCodeLine{297     \textcolor{keywordtype}{bool} result = \_\_savePPM(file, idata, w, h, 1);}
\DoxyCodeLine{298 }
\DoxyCodeLine{299     \textcolor{comment}{// cleanup}}
\DoxyCodeLine{300     free(idata);}
\DoxyCodeLine{301 }
\DoxyCodeLine{302     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{303 \}}
\DoxyCodeLine{304 }
\DoxyCodeLine{305 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkSavePPM4ub(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} h) \{}
\DoxyCodeLine{306     \textcolor{comment}{// strip 4th component}}
\DoxyCodeLine{307     \textcolor{keywordtype}{int} size             = w * h;}
\DoxyCodeLine{308     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ndata = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}) * size * 3);}
\DoxyCodeLine{309     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ptr   = ndata;}
\DoxyCodeLine{310 }
\DoxyCodeLine{311     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < size; i++) \{}
\DoxyCodeLine{312         *ptr++ = *data++;}
\DoxyCodeLine{313         *ptr++ = *data++;}
\DoxyCodeLine{314         *ptr++ = *data++;}
\DoxyCodeLine{315         data++;}
\DoxyCodeLine{316     \}}
\DoxyCodeLine{317 }
\DoxyCodeLine{318     \textcolor{keywordtype}{bool} result = \_\_savePPM(file, ndata, w, h, 3);}
\DoxyCodeLine{319     free(ndata);}
\DoxyCodeLine{320     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{321 \}}
\DoxyCodeLine{322 }
\DoxyCodeLine{331 \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{332 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkReadFile(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename, T **data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *len, \textcolor{keywordtype}{bool} verbose) \{}
\DoxyCodeLine{333     \textcolor{comment}{// check input arguments}}
\DoxyCodeLine{334     assert(NULL != filename);}
\DoxyCodeLine{335     assert(NULL != len);}
\DoxyCodeLine{336 }
\DoxyCodeLine{337     \textcolor{comment}{// intermediate storage for the data read}}
\DoxyCodeLine{338     std::vector<T> data\_read;}
\DoxyCodeLine{339 }
\DoxyCodeLine{340     \textcolor{comment}{// open file for reading}}
\DoxyCodeLine{341     FILE *fh = NULL;}
\DoxyCodeLine{342 }
\DoxyCodeLine{343     \textcolor{comment}{// check if filestream is valid}}
\DoxyCodeLine{344     \textcolor{keywordflow}{if} (FOPEN\_FAIL(FOPEN(fh, filename, \textcolor{stringliteral}{"{}r"{}}))) \{}
\DoxyCodeLine{345         printf(\textcolor{stringliteral}{"{}Unable to open input file: \%s\(\backslash\)n"{}}, filename);}
\DoxyCodeLine{346         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{347     \}}
\DoxyCodeLine{348 }
\DoxyCodeLine{349     \textcolor{comment}{// read all data elements}}
\DoxyCodeLine{350     T token;}
\DoxyCodeLine{351 }
\DoxyCodeLine{352     \textcolor{keywordflow}{while} (!feof(fh)) \{}
\DoxyCodeLine{353         fscanf(fh, \textcolor{stringliteral}{"{}\%f"{}}, \&token);}
\DoxyCodeLine{354         data\_read.push\_back(token);}
\DoxyCodeLine{355     \}}
\DoxyCodeLine{356 }
\DoxyCodeLine{357     \textcolor{comment}{// the last element is read twice}}
\DoxyCodeLine{358     data\_read.pop\_back();}
\DoxyCodeLine{359     fclose(fh);}
\DoxyCodeLine{360 }
\DoxyCodeLine{361     \textcolor{comment}{// check if the given handle is already initialized}}
\DoxyCodeLine{362     \textcolor{keywordflow}{if} (NULL != *data) \{}
\DoxyCodeLine{363         \textcolor{keywordflow}{if} (*len != data\_read.size()) \{}
\DoxyCodeLine{364             std::cerr << \textcolor{stringliteral}{"{}sdkReadFile() : Initialized memory given but "{}}}
\DoxyCodeLine{365                       << \textcolor{stringliteral}{"{}size  mismatch with signal read "{}}}
\DoxyCodeLine{366                       << \textcolor{stringliteral}{"{}(data read / data init = "{}} << (\textcolor{keywordtype}{unsigned} int)data\_read.size() << \textcolor{stringliteral}{"{} / "{}}}
\DoxyCodeLine{367                       << *len << \textcolor{stringliteral}{"{})"{}} << std::endl;}
\DoxyCodeLine{368 }
\DoxyCodeLine{369             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{370         \}}
\DoxyCodeLine{371     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{372         \textcolor{comment}{// allocate storage for the data read}}
\DoxyCodeLine{373         *data = \textcolor{keyword}{reinterpret\_cast<}T *\textcolor{keyword}{>}(malloc(\textcolor{keyword}{sizeof}(T) * data\_read.size()));}
\DoxyCodeLine{374         \textcolor{comment}{// store signal size}}
\DoxyCodeLine{375         *len = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}\textcolor{keyword}{>}(data\_read.size());}
\DoxyCodeLine{376     \}}
\DoxyCodeLine{377 }
\DoxyCodeLine{378     \textcolor{comment}{// copy data}}
\DoxyCodeLine{379     memcpy(*data, \&data\_read.front(), \textcolor{keyword}{sizeof}(T) * data\_read.size());}
\DoxyCodeLine{380 }
\DoxyCodeLine{381     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{382 \}}
\DoxyCodeLine{383 }
\DoxyCodeLine{392 \textcolor{keyword}{template}<\textcolor{keyword}{class} T>}
\DoxyCodeLine{393 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkReadFileBlocks(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename, T **data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *len,}
\DoxyCodeLine{394                               \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} block\_num, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} block\_size, \textcolor{keywordtype}{bool} verbose) \{}
\DoxyCodeLine{395     \textcolor{comment}{// check input arguments}}
\DoxyCodeLine{396     assert(NULL != filename);}
\DoxyCodeLine{397     assert(NULL != len);}
\DoxyCodeLine{398 }
\DoxyCodeLine{399     \textcolor{comment}{// open file for reading}}
\DoxyCodeLine{400     FILE *fh = fopen(filename, \textcolor{stringliteral}{"{}rb"{}});}
\DoxyCodeLine{401 }
\DoxyCodeLine{402     \textcolor{keywordflow}{if} (fh == NULL \&\& verbose) \{}
\DoxyCodeLine{403         std::cerr << \textcolor{stringliteral}{"{}sdkReadFile() : Opening file failed."{}} << std::endl;}
\DoxyCodeLine{404         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{405     \}}
\DoxyCodeLine{406 }
\DoxyCodeLine{407     \textcolor{comment}{// check if the given handle is already initialized}}
\DoxyCodeLine{408     \textcolor{comment}{// allocate storage for the data read}}
\DoxyCodeLine{409     data[block\_num] = \textcolor{keyword}{reinterpret\_cast<}T *\textcolor{keyword}{>}(malloc(block\_size));}
\DoxyCodeLine{410 }
\DoxyCodeLine{411     \textcolor{comment}{// read all data elements}}
\DoxyCodeLine{412     fseek(fh, block\_num * block\_size, SEEK\_SET);}
\DoxyCodeLine{413     *len = fread(data[block\_num], \textcolor{keyword}{sizeof}(T), block\_size / \textcolor{keyword}{sizeof}(T), fh);}
\DoxyCodeLine{414 }
\DoxyCodeLine{415     fclose(fh);}
\DoxyCodeLine{416 }
\DoxyCodeLine{417     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{418 \}}
\DoxyCodeLine{419 }
\DoxyCodeLine{428 \textcolor{keyword}{template}<\textcolor{keyword}{class} T, \textcolor{keyword}{class} S>}
\DoxyCodeLine{429 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkWriteFile(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename, \textcolor{keyword}{const} T *data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len, \textcolor{keyword}{const} S epsilon,}
\DoxyCodeLine{430                          \textcolor{keywordtype}{bool} verbose, \textcolor{keywordtype}{bool} append = \textcolor{keyword}{false}) \{}
\DoxyCodeLine{431     assert(NULL != filename);}
\DoxyCodeLine{432     assert(NULL != data);}
\DoxyCodeLine{433 }
\DoxyCodeLine{434     \textcolor{comment}{// open file for writing}}
\DoxyCodeLine{435     \textcolor{comment}{//    if (append) \{}}
\DoxyCodeLine{436     std::fstream fh(filename, std::fstream::out | std::fstream::ate);}
\DoxyCodeLine{437 }
\DoxyCodeLine{438     \textcolor{keywordflow}{if} (verbose) \{}
\DoxyCodeLine{439         std::cerr << \textcolor{stringliteral}{"{}sdkWriteFile() : Open file "{}} << filename << \textcolor{stringliteral}{"{} for write/append."{}} << std::endl;}
\DoxyCodeLine{440     \}}
\DoxyCodeLine{441 }
\DoxyCodeLine{442     \textcolor{comment}{/*    \} else \{}}
\DoxyCodeLine{443 \textcolor{comment}{            std::fstream fh(filename, std::fstream::out);}}
\DoxyCodeLine{444 \textcolor{comment}{            if (verbose) \{}}
\DoxyCodeLine{445 \textcolor{comment}{                std::cerr << "{}sdkWriteFile() : Open file "{} << filename << "{} for}}
\DoxyCodeLine{446 \textcolor{comment}{       write."{} << std::endl;}}
\DoxyCodeLine{447 \textcolor{comment}{            \}}}
\DoxyCodeLine{448 \textcolor{comment}{        \}}}
\DoxyCodeLine{449 \textcolor{comment}{    */}}
\DoxyCodeLine{450 }
\DoxyCodeLine{451     \textcolor{comment}{// check if filestream is valid}}
\DoxyCodeLine{452     \textcolor{keywordflow}{if} (!fh.good()) \{}
\DoxyCodeLine{453         \textcolor{keywordflow}{if} (verbose) \{ std::cerr << \textcolor{stringliteral}{"{}sdkWriteFile() : Opening file failed."{}} << std::endl; \}}
\DoxyCodeLine{454 }
\DoxyCodeLine{455         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{456     \}}
\DoxyCodeLine{457 }
\DoxyCodeLine{458     \textcolor{comment}{// first write epsilon}}
\DoxyCodeLine{459     fh << \textcolor{stringliteral}{"{}\# "{}} << epsilon << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{460 }
\DoxyCodeLine{461     \textcolor{comment}{// write data}}
\DoxyCodeLine{462     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; (i < len) \&\& (fh.good()); ++i) \{ fh << data[i] << \textcolor{charliteral}{' '}; \}}
\DoxyCodeLine{463 }
\DoxyCodeLine{464     \textcolor{comment}{// Check if writing succeeded}}
\DoxyCodeLine{465     \textcolor{keywordflow}{if} (!fh.good()) \{}
\DoxyCodeLine{466         \textcolor{keywordflow}{if} (verbose) \{ std::cerr << \textcolor{stringliteral}{"{}sdkWriteFile() : Writing file failed."{}} << std::endl; \}}
\DoxyCodeLine{467 }
\DoxyCodeLine{468         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{469     \}}
\DoxyCodeLine{470 }
\DoxyCodeLine{471     \textcolor{comment}{// file ends with nl}}
\DoxyCodeLine{472     fh << std::endl;}
\DoxyCodeLine{473 }
\DoxyCodeLine{474     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{475 \}}
\DoxyCodeLine{476 }
\DoxyCodeLine{485 \textcolor{keyword}{template}<\textcolor{keyword}{class} T, \textcolor{keyword}{class} S>}
\DoxyCodeLine{486 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} compareData(\textcolor{keyword}{const} T *reference, \textcolor{keyword}{const} T *data, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len, \textcolor{keyword}{const} S epsilon,}
\DoxyCodeLine{487                         \textcolor{keyword}{const} \textcolor{keywordtype}{float} threshold) \{}
\DoxyCodeLine{488     assert(epsilon >= 0);}
\DoxyCodeLine{489 }
\DoxyCodeLine{490     \textcolor{keywordtype}{bool} result              = \textcolor{keyword}{true};}
\DoxyCodeLine{491     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} error\_count = 0;}
\DoxyCodeLine{492 }
\DoxyCodeLine{493     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < len; ++i) \{}
\DoxyCodeLine{494         \textcolor{keywordtype}{float} diff = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(reference[i]) -\/ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(data[i]);}
\DoxyCodeLine{495         \textcolor{keywordtype}{bool} comp  = (diff <= epsilon) \&\& (diff >= -\/epsilon);}
\DoxyCodeLine{496         result \&= comp;}
\DoxyCodeLine{497 }
\DoxyCodeLine{498         error\_count += !comp;}
\DoxyCodeLine{499 }
\DoxyCodeLine{500 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{501 }
\DoxyCodeLine{502         \textcolor{keywordflow}{if} (!comp) \{}
\DoxyCodeLine{503           std::cerr << \textcolor{stringliteral}{"{}ERROR, i = "{}} << i << \textcolor{stringliteral}{"{},\(\backslash\)t "{}}}
\DoxyCodeLine{504                     << reference[i] << \textcolor{stringliteral}{"{} / "{}}}
\DoxyCodeLine{505                     << data[i]}
\DoxyCodeLine{506                     << \textcolor{stringliteral}{"{} (reference / data)\(\backslash\)n"{}};}
\DoxyCodeLine{507         \}}
\DoxyCodeLine{508 }
\DoxyCodeLine{509 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{510     \}}
\DoxyCodeLine{511 }
\DoxyCodeLine{512     \textcolor{keywordflow}{if} (threshold == 0.0f) \{}
\DoxyCodeLine{513         \textcolor{keywordflow}{return} (result) ? true : \textcolor{keyword}{false};}
\DoxyCodeLine{514     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{515         \textcolor{keywordflow}{if} (error\_count) \{}
\DoxyCodeLine{516             printf(\textcolor{stringliteral}{"{}\%4.2f(\%\%) of bytes mismatched (count=\%d)\(\backslash\)n"{}},}
\DoxyCodeLine{517                    \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(error\_count) * 100 / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(len),}
\DoxyCodeLine{518                    error\_count);}
\DoxyCodeLine{519         \}}
\DoxyCodeLine{520 }
\DoxyCodeLine{521         \textcolor{keywordflow}{return} (len * threshold > error\_count) ? true : \textcolor{keyword}{false};}
\DoxyCodeLine{522     \}}
\DoxyCodeLine{523 \}}
\DoxyCodeLine{524 }
\DoxyCodeLine{525 \textcolor{preprocessor}{\#ifndef \_\_MIN\_EPSILON\_ERROR}}
\DoxyCodeLine{526 \textcolor{preprocessor}{\#   define \_\_MIN\_EPSILON\_ERROR 1e-\/3f}}
\DoxyCodeLine{527 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{528 }
\DoxyCodeLine{538 \textcolor{keyword}{template}<\textcolor{keyword}{class} T, \textcolor{keyword}{class} S>}
\DoxyCodeLine{539 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} compareDataAsFloatThreshold(\textcolor{keyword}{const} T *reference, \textcolor{keyword}{const} T *data, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len,}
\DoxyCodeLine{540                                         \textcolor{keyword}{const} S epsilon, \textcolor{keyword}{const} \textcolor{keywordtype}{float} threshold) \{}
\DoxyCodeLine{541     assert(epsilon >= 0);}
\DoxyCodeLine{542 }
\DoxyCodeLine{543     \textcolor{comment}{// If we set epsilon to be 0, let's set a minimum threshold}}
\DoxyCodeLine{544     \textcolor{keywordtype}{float} max\_error = MAX((\textcolor{keywordtype}{float})epsilon, \_\_MIN\_EPSILON\_ERROR);}
\DoxyCodeLine{545     \textcolor{keywordtype}{int} error\_count = 0;}
\DoxyCodeLine{546     \textcolor{keywordtype}{bool} result     = \textcolor{keyword}{true};}
\DoxyCodeLine{547 }
\DoxyCodeLine{548     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < len; ++i) \{}
\DoxyCodeLine{549         \textcolor{keywordtype}{float} diff = fabs(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(reference[i]) -\/ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(data[i]));}
\DoxyCodeLine{550         \textcolor{keywordtype}{bool} comp  = (diff < max\_error);}
\DoxyCodeLine{551         result \&= comp;}
\DoxyCodeLine{552 }
\DoxyCodeLine{553         \textcolor{keywordflow}{if} (!comp) \{ error\_count++; \}}
\DoxyCodeLine{554     \}}
\DoxyCodeLine{555 }
\DoxyCodeLine{556     \textcolor{keywordflow}{if} (threshold == 0.0f) \{}
\DoxyCodeLine{557         \textcolor{keywordflow}{if} (error\_count) \{ printf(\textcolor{stringliteral}{"{}total \# of errors = \%d\(\backslash\)n"{}}, error\_count); \}}
\DoxyCodeLine{558 }
\DoxyCodeLine{559         \textcolor{keywordflow}{return} (error\_count == 0) ? true : \textcolor{keyword}{false};}
\DoxyCodeLine{560     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{561         \textcolor{keywordflow}{if} (error\_count) \{}
\DoxyCodeLine{562             printf(\textcolor{stringliteral}{"{}\%4.2f(\%\%) of bytes mismatched (count=\%d)\(\backslash\)n"{}},}
\DoxyCodeLine{563                    \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(error\_count) * 100 / \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(len),}
\DoxyCodeLine{564                    error\_count);}
\DoxyCodeLine{565         \}}
\DoxyCodeLine{566 }
\DoxyCodeLine{567         \textcolor{keywordflow}{return} ((len * threshold > error\_count) ? \textcolor{keyword}{true} : \textcolor{keyword}{false});}
\DoxyCodeLine{568     \}}
\DoxyCodeLine{569 \}}
\DoxyCodeLine{570 }
\DoxyCodeLine{571 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} sdkDumpBin(\textcolor{keywordtype}{void} *data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bytes, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename) \{}
\DoxyCodeLine{572     printf(\textcolor{stringliteral}{"{}sdkDumpBin: <\%s>\(\backslash\)n"{}}, filename);}
\DoxyCodeLine{573     FILE *fp;}
\DoxyCodeLine{574     FOPEN(fp, filename, \textcolor{stringliteral}{"{}wb"{}});}
\DoxyCodeLine{575     fwrite(data, bytes, 1, fp);}
\DoxyCodeLine{576     fflush(fp);}
\DoxyCodeLine{577     fclose(fp);}
\DoxyCodeLine{578 \}}
\DoxyCodeLine{579 }
\DoxyCodeLine{580 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkCompareBin2BinUint(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *src\_file, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *ref\_file,}
\DoxyCodeLine{581                                   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nelements, \textcolor{keyword}{const} \textcolor{keywordtype}{float} epsilon,}
\DoxyCodeLine{582                                   \textcolor{keyword}{const} \textcolor{keywordtype}{float} threshold, \textcolor{keywordtype}{char} *exec\_path) \{}
\DoxyCodeLine{583     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *src\_buffer, *ref\_buffer;}
\DoxyCodeLine{584     FILE *src\_fp = NULL, *ref\_fp = NULL;}
\DoxyCodeLine{585 }
\DoxyCodeLine{586     uint64\_t error\_count = 0;}
\DoxyCodeLine{587     \textcolor{keywordtype}{size\_t} fsize         = 0;}
\DoxyCodeLine{588 }
\DoxyCodeLine{589     \textcolor{keywordflow}{if} (FOPEN\_FAIL(FOPEN(src\_fp, src\_file, \textcolor{stringliteral}{"{}rb"{}}))) \{}
\DoxyCodeLine{590         printf(\textcolor{stringliteral}{"{}compareBin2Bin <unsigned int> unable to open src\_file: \%s\(\backslash\)n"{}}, src\_file);}
\DoxyCodeLine{591         error\_count++;}
\DoxyCodeLine{592     \}}
\DoxyCodeLine{593 }
\DoxyCodeLine{594     \textcolor{keywordtype}{char} *ref\_file\_path = sdkFindFilePath(ref\_file, exec\_path);}
\DoxyCodeLine{595 }
\DoxyCodeLine{596     \textcolor{keywordflow}{if} (ref\_file\_path == NULL) \{}
\DoxyCodeLine{597         printf(\textcolor{stringliteral}{"{}compareBin2Bin <unsigned int>  unable to find <\%s> in <\%s>\(\backslash\)n"{}}, ref\_file, exec\_path);}
\DoxyCodeLine{598         printf(\textcolor{stringliteral}{"{}>>> Check info.xml and [project//data] folder <\%s> <<<\(\backslash\)n"{}}, ref\_file);}
\DoxyCodeLine{599         printf(\textcolor{stringliteral}{"{}Aborting comparison!\(\backslash\)n"{}});}
\DoxyCodeLine{600         printf(\textcolor{stringliteral}{"{}  FAILED\(\backslash\)n"{}});}
\DoxyCodeLine{601         error\_count++;}
\DoxyCodeLine{602 }
\DoxyCodeLine{603         \textcolor{keywordflow}{if} (src\_fp) \{ fclose(src\_fp); \}}
\DoxyCodeLine{604 }
\DoxyCodeLine{605         \textcolor{keywordflow}{if} (ref\_fp) \{ fclose(ref\_fp); \}}
\DoxyCodeLine{606     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{607         \textcolor{keywordflow}{if} (FOPEN\_FAIL(FOPEN(ref\_fp, ref\_file\_path, \textcolor{stringliteral}{"{}rb"{}}))) \{}
\DoxyCodeLine{608             printf(}
\DoxyCodeLine{609               \textcolor{stringliteral}{"{}compareBin2Bin <unsigned int>"{}}}
\DoxyCodeLine{610               \textcolor{stringliteral}{"{} unable to open ref\_file: \%s\(\backslash\)n"{}},}
\DoxyCodeLine{611               ref\_file\_path);}
\DoxyCodeLine{612             error\_count++;}
\DoxyCodeLine{613         \}}
\DoxyCodeLine{614 }
\DoxyCodeLine{615         \textcolor{keywordflow}{if} (src\_fp \&\& ref\_fp) \{}
\DoxyCodeLine{616             src\_buffer = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *)malloc(nelements * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));}
\DoxyCodeLine{617             ref\_buffer = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *)malloc(nelements * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));}
\DoxyCodeLine{618 }
\DoxyCodeLine{619             fsize = fread(src\_buffer, nelements, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}), src\_fp);}
\DoxyCodeLine{620             fsize = fread(ref\_buffer, nelements, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}), ref\_fp);}
\DoxyCodeLine{621 }
\DoxyCodeLine{622             printf(}
\DoxyCodeLine{623               \textcolor{stringliteral}{"{}> compareBin2Bin <unsigned int> nelements=\%d,"{}}}
\DoxyCodeLine{624               \textcolor{stringliteral}{"{} epsilon=\%4.2f, threshold=\%4.2f\(\backslash\)n"{}},}
\DoxyCodeLine{625               nelements,}
\DoxyCodeLine{626               epsilon,}
\DoxyCodeLine{627               threshold);}
\DoxyCodeLine{628             printf(\textcolor{stringliteral}{"{}   src\_file <\%s>, size=\%d bytes\(\backslash\)n"{}}, src\_file, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(fsize));}
\DoxyCodeLine{629             printf(\textcolor{stringliteral}{"{}   ref\_file <\%s>, size=\%d bytes\(\backslash\)n"{}}, ref\_file\_path, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(fsize));}
\DoxyCodeLine{630 }
\DoxyCodeLine{631             \textcolor{keywordflow}{if} (!compareData<unsigned int, float>(}
\DoxyCodeLine{632                   ref\_buffer, src\_buffer, nelements, epsilon, threshold)) \{}
\DoxyCodeLine{633                 error\_count++;}
\DoxyCodeLine{634             \}}
\DoxyCodeLine{635 }
\DoxyCodeLine{636             fclose(src\_fp);}
\DoxyCodeLine{637             fclose(ref\_fp);}
\DoxyCodeLine{638 }
\DoxyCodeLine{639             free(src\_buffer);}
\DoxyCodeLine{640             free(ref\_buffer);}
\DoxyCodeLine{641         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{642             \textcolor{keywordflow}{if} (src\_fp) \{ fclose(src\_fp); \}}
\DoxyCodeLine{643 }
\DoxyCodeLine{644             \textcolor{keywordflow}{if} (ref\_fp) \{ fclose(ref\_fp); \}}
\DoxyCodeLine{645         \}}
\DoxyCodeLine{646     \}}
\DoxyCodeLine{647 }
\DoxyCodeLine{648     \textcolor{keywordflow}{if} (error\_count == 0) \{}
\DoxyCodeLine{649         printf(\textcolor{stringliteral}{"{}  OK\(\backslash\)n"{}});}
\DoxyCodeLine{650     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{651         printf(\textcolor{stringliteral}{"{}  FAILURE: \%d errors...\(\backslash\)n"{}}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})error\_count);}
\DoxyCodeLine{652     \}}
\DoxyCodeLine{653 }
\DoxyCodeLine{654     \textcolor{keywordflow}{return} (error\_count == 0); \textcolor{comment}{// returns true if all pixels pass}}
\DoxyCodeLine{655 \}}
\DoxyCodeLine{656 }
\DoxyCodeLine{657 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkCompareBin2BinFloat(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *src\_file, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *ref\_file,}
\DoxyCodeLine{658                                    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nelements, \textcolor{keyword}{const} \textcolor{keywordtype}{float} epsilon,}
\DoxyCodeLine{659                                    \textcolor{keyword}{const} \textcolor{keywordtype}{float} threshold, \textcolor{keywordtype}{char} *exec\_path) \{}
\DoxyCodeLine{660     \textcolor{keywordtype}{float} *src\_buffer = NULL, *ref\_buffer = NULL;}
\DoxyCodeLine{661     FILE *src\_fp = NULL, *ref\_fp = NULL;}
\DoxyCodeLine{662     \textcolor{keywordtype}{size\_t} fsize = 0;}
\DoxyCodeLine{663 }
\DoxyCodeLine{664     uint64\_t error\_count = 0;}
\DoxyCodeLine{665 }
\DoxyCodeLine{666     \textcolor{keywordflow}{if} (FOPEN\_FAIL(FOPEN(src\_fp, src\_file, \textcolor{stringliteral}{"{}rb"{}}))) \{}
\DoxyCodeLine{667         printf(\textcolor{stringliteral}{"{}compareBin2Bin <float> unable to open src\_file: \%s\(\backslash\)n"{}}, src\_file);}
\DoxyCodeLine{668         error\_count = 1;}
\DoxyCodeLine{669     \}}
\DoxyCodeLine{670 }
\DoxyCodeLine{671     \textcolor{keywordtype}{char} *ref\_file\_path = sdkFindFilePath(ref\_file, exec\_path);}
\DoxyCodeLine{672 }
\DoxyCodeLine{673     \textcolor{keywordflow}{if} (ref\_file\_path == NULL) \{}
\DoxyCodeLine{674         printf(\textcolor{stringliteral}{"{}compareBin2Bin <float> unable to find <\%s> in <\%s>\(\backslash\)n"{}}, ref\_file, exec\_path);}
\DoxyCodeLine{675         printf(\textcolor{stringliteral}{"{}>>> Check info.xml and [project//data] folder <\%s> <<<\(\backslash\)n"{}}, exec\_path);}
\DoxyCodeLine{676         printf(\textcolor{stringliteral}{"{}Aborting comparison!\(\backslash\)n"{}});}
\DoxyCodeLine{677         printf(\textcolor{stringliteral}{"{}  FAILED\(\backslash\)n"{}});}
\DoxyCodeLine{678         error\_count++;}
\DoxyCodeLine{679 }
\DoxyCodeLine{680         \textcolor{keywordflow}{if} (src\_fp) \{ fclose(src\_fp); \}}
\DoxyCodeLine{681 }
\DoxyCodeLine{682         \textcolor{keywordflow}{if} (ref\_fp) \{ fclose(ref\_fp); \}}
\DoxyCodeLine{683     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{684         \textcolor{keywordflow}{if} (FOPEN\_FAIL(FOPEN(ref\_fp, ref\_file\_path, \textcolor{stringliteral}{"{}rb"{}}))) \{}
\DoxyCodeLine{685             printf(\textcolor{stringliteral}{"{}compareBin2Bin <float> unable to open ref\_file: \%s\(\backslash\)n"{}}, ref\_file\_path);}
\DoxyCodeLine{686             error\_count = 1;}
\DoxyCodeLine{687         \}}
\DoxyCodeLine{688 }
\DoxyCodeLine{689         \textcolor{keywordflow}{if} (src\_fp \&\& ref\_fp) \{}
\DoxyCodeLine{690             src\_buffer = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{float} *\textcolor{keyword}{>}(malloc(nelements * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float})));}
\DoxyCodeLine{691             ref\_buffer = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{float} *\textcolor{keyword}{>}(malloc(nelements * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float})));}
\DoxyCodeLine{692 }
\DoxyCodeLine{693             printf(}
\DoxyCodeLine{694               \textcolor{stringliteral}{"{}> compareBin2Bin <float> nelements=\%d, epsilon=\%4.2f,"{}}}
\DoxyCodeLine{695               \textcolor{stringliteral}{"{} threshold=\%4.2f\(\backslash\)n"{}},}
\DoxyCodeLine{696               nelements,}
\DoxyCodeLine{697               epsilon,}
\DoxyCodeLine{698               threshold);}
\DoxyCodeLine{699             fsize = fread(src\_buffer, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), nelements, src\_fp);}
\DoxyCodeLine{700             printf(\textcolor{stringliteral}{"{}   src\_file <\%s>, size=\%d bytes\(\backslash\)n"{}},}
\DoxyCodeLine{701                    src\_file,}
\DoxyCodeLine{702                    \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(fsize * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float})));}
\DoxyCodeLine{703             fsize = fread(ref\_buffer, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}), nelements, ref\_fp);}
\DoxyCodeLine{704             printf(\textcolor{stringliteral}{"{}   ref\_file <\%s>, size=\%d bytes\(\backslash\)n"{}},}
\DoxyCodeLine{705                    ref\_file\_path,}
\DoxyCodeLine{706                    \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(fsize * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float})));}
\DoxyCodeLine{707 }
\DoxyCodeLine{708             \textcolor{keywordflow}{if} (!compareDataAsFloatThreshold<float, float>(}
\DoxyCodeLine{709                   ref\_buffer, src\_buffer, nelements, epsilon, threshold)) \{}
\DoxyCodeLine{710                 error\_count++;}
\DoxyCodeLine{711             \}}
\DoxyCodeLine{712 }
\DoxyCodeLine{713             fclose(src\_fp);}
\DoxyCodeLine{714             fclose(ref\_fp);}
\DoxyCodeLine{715 }
\DoxyCodeLine{716             free(src\_buffer);}
\DoxyCodeLine{717             free(ref\_buffer);}
\DoxyCodeLine{718         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{719             \textcolor{keywordflow}{if} (src\_fp) \{ fclose(src\_fp); \}}
\DoxyCodeLine{720 }
\DoxyCodeLine{721             \textcolor{keywordflow}{if} (ref\_fp) \{ fclose(ref\_fp); \}}
\DoxyCodeLine{722         \}}
\DoxyCodeLine{723     \}}
\DoxyCodeLine{724 }
\DoxyCodeLine{725     \textcolor{keywordflow}{if} (error\_count == 0) \{}
\DoxyCodeLine{726         printf(\textcolor{stringliteral}{"{}  OK\(\backslash\)n"{}});}
\DoxyCodeLine{727     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{728         printf(\textcolor{stringliteral}{"{}  FAILURE: \%d errors...\(\backslash\)n"{}}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})error\_count);}
\DoxyCodeLine{729     \}}
\DoxyCodeLine{730 }
\DoxyCodeLine{731     \textcolor{keywordflow}{return} (error\_count == 0); \textcolor{comment}{// returns true if all pixels pass}}
\DoxyCodeLine{732 \}}
\DoxyCodeLine{733 }
\DoxyCodeLine{734 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkCompareL2fe(\textcolor{keyword}{const} \textcolor{keywordtype}{float} *reference, \textcolor{keyword}{const} \textcolor{keywordtype}{float} *data, \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len,}
\DoxyCodeLine{735                            \textcolor{keyword}{const} \textcolor{keywordtype}{float} epsilon) \{}
\DoxyCodeLine{736     assert(epsilon >= 0);}
\DoxyCodeLine{737 }
\DoxyCodeLine{738     \textcolor{keywordtype}{float} error = 0;}
\DoxyCodeLine{739     \textcolor{keywordtype}{float} ref   = 0;}
\DoxyCodeLine{740 }
\DoxyCodeLine{741     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < len; ++i) \{}
\DoxyCodeLine{742         \textcolor{keywordtype}{float} diff = reference[i] -\/ data[i];}
\DoxyCodeLine{743         error += diff * diff;}
\DoxyCodeLine{744         ref += reference[i] * reference[i];}
\DoxyCodeLine{745     \}}
\DoxyCodeLine{746 }
\DoxyCodeLine{747     \textcolor{keywordtype}{float} normRef = sqrtf(ref);}
\DoxyCodeLine{748 }
\DoxyCodeLine{749     \textcolor{keywordflow}{if} (fabs(ref) < 1e-\/7) \{}
\DoxyCodeLine{750 \textcolor{preprocessor}{\#ifdef \_DEBUG}}
\DoxyCodeLine{751         std::cerr << \textcolor{stringliteral}{"{}ERROR, reference l2-\/norm is 0\(\backslash\)n"{}};}
\DoxyCodeLine{752 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{753         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{754     \}}
\DoxyCodeLine{755 }
\DoxyCodeLine{756     \textcolor{keywordtype}{float} normError = sqrtf(error);}
\DoxyCodeLine{757     error           = normError / normRef;}
\DoxyCodeLine{758     \textcolor{keywordtype}{bool} result     = error < epsilon;}
\DoxyCodeLine{759 \textcolor{preprocessor}{\#ifdef \_DEBUG}}
\DoxyCodeLine{760 }
\DoxyCodeLine{761     \textcolor{keywordflow}{if} (!result) \{}
\DoxyCodeLine{762         std::cerr << \textcolor{stringliteral}{"{}ERROR, l2-\/norm error "{}} << error << \textcolor{stringliteral}{"{} is greater than epsilon "{}} << epsilon}
\DoxyCodeLine{763                   << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{764     \}}
\DoxyCodeLine{765 }
\DoxyCodeLine{766 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{767 }
\DoxyCodeLine{768     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{769 \}}
\DoxyCodeLine{770 }
\DoxyCodeLine{771 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkLoadPPMub(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *w, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *h) \{}
\DoxyCodeLine{772     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} channels;}
\DoxyCodeLine{773     \textcolor{keywordflow}{return} \_\_loadPPM(file, data, w, h, \&channels);}
\DoxyCodeLine{774 \}}
\DoxyCodeLine{775 }
\DoxyCodeLine{776 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkLoadPPM4ub(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *file, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} **data, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *w,}
\DoxyCodeLine{777                           \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} *h) \{}
\DoxyCodeLine{778     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *idata = 0;}
\DoxyCodeLine{779     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} channels;}
\DoxyCodeLine{780 }
\DoxyCodeLine{781     \textcolor{keywordflow}{if} (\_\_loadPPM(file, \&idata, w, h, \&channels)) \{}
\DoxyCodeLine{782         \textcolor{comment}{// pad 4th component}}
\DoxyCodeLine{783         \textcolor{keywordtype}{int} size = *w * *h;}
\DoxyCodeLine{784         \textcolor{comment}{// keep the original pointer}}
\DoxyCodeLine{785         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *idata\_orig = idata;}
\DoxyCodeLine{786         *data                     = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)malloc(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}) * size * 4);}
\DoxyCodeLine{787         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ptr        = *data;}
\DoxyCodeLine{788 }
\DoxyCodeLine{789         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < size; i++) \{}
\DoxyCodeLine{790             *ptr++ = *idata++;}
\DoxyCodeLine{791             *ptr++ = *idata++;}
\DoxyCodeLine{792             *ptr++ = *idata++;}
\DoxyCodeLine{793             *ptr++ = 0;}
\DoxyCodeLine{794         \}}
\DoxyCodeLine{795 }
\DoxyCodeLine{796         free(idata\_orig);}
\DoxyCodeLine{797         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{798     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{799         free(idata);}
\DoxyCodeLine{800         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{801     \}}
\DoxyCodeLine{802 \}}
\DoxyCodeLine{803 }
\DoxyCodeLine{804 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkComparePPM(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *src\_file, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *ref\_file, \textcolor{keyword}{const} \textcolor{keywordtype}{float} epsilon,}
\DoxyCodeLine{805                           \textcolor{keyword}{const} \textcolor{keywordtype}{float} threshold, \textcolor{keywordtype}{bool} verboseErrors) \{}
\DoxyCodeLine{806     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *src\_data, *ref\_data;}
\DoxyCodeLine{807     uint64\_t error\_count = 0;}
\DoxyCodeLine{808     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ref\_width, ref\_height;}
\DoxyCodeLine{809     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} src\_width, src\_height;}
\DoxyCodeLine{810 }
\DoxyCodeLine{811     \textcolor{keywordflow}{if} (src\_file == NULL || ref\_file == NULL) \{}
\DoxyCodeLine{812         \textcolor{keywordflow}{if} (verboseErrors) \{}
\DoxyCodeLine{813             std::cerr << \textcolor{stringliteral}{"{}PPMvsPPM: src\_file or ref\_file is NULL."{}}}
\DoxyCodeLine{814                          \textcolor{stringliteral}{"{}  Aborting comparison\(\backslash\)n"{}};}
\DoxyCodeLine{815         \}}
\DoxyCodeLine{816 }
\DoxyCodeLine{817         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{818     \}}
\DoxyCodeLine{819 }
\DoxyCodeLine{820     \textcolor{keywordflow}{if} (verboseErrors) \{}
\DoxyCodeLine{821         std::cerr << \textcolor{stringliteral}{"{}> Compare (a)rendered:  <"{}} << src\_file << \textcolor{stringliteral}{"{}>\(\backslash\)n"{}};}
\DoxyCodeLine{822         std::cerr << \textcolor{stringliteral}{"{}>         (b)reference: <"{}} << ref\_file << \textcolor{stringliteral}{"{}>\(\backslash\)n"{}};}
\DoxyCodeLine{823     \}}
\DoxyCodeLine{824 }
\DoxyCodeLine{825     \textcolor{keywordflow}{if} (sdkLoadPPM4ub(ref\_file, \&ref\_data, \&ref\_width, \&ref\_height) != \textcolor{keyword}{true}) \{}
\DoxyCodeLine{826         \textcolor{keywordflow}{if} (verboseErrors) \{}
\DoxyCodeLine{827             std::cerr << \textcolor{stringliteral}{"{}PPMvsPPM: unable to load ref image file: "{}} << ref\_file << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{828         \}}
\DoxyCodeLine{829 }
\DoxyCodeLine{830         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{831     \}}
\DoxyCodeLine{832 }
\DoxyCodeLine{833     \textcolor{keywordflow}{if} (sdkLoadPPM4ub(src\_file, \&src\_data, \&src\_width, \&src\_height) != \textcolor{keyword}{true}) \{}
\DoxyCodeLine{834         std::cerr << \textcolor{stringliteral}{"{}PPMvsPPM: unable to load src image file: "{}} << src\_file << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{835         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{836     \}}
\DoxyCodeLine{837 }
\DoxyCodeLine{838     \textcolor{keywordflow}{if} (src\_height != ref\_height || src\_width != ref\_width) \{}
\DoxyCodeLine{839         \textcolor{keywordflow}{if} (verboseErrors) \{}
\DoxyCodeLine{840             std::cerr << \textcolor{stringliteral}{"{}PPMvsPPM: source and ref size mismatch ("{}} << src\_width << \textcolor{stringliteral}{"{},"{}}}
\DoxyCodeLine{841                       << src\_height << \textcolor{stringliteral}{"{})vs("{}} << ref\_width << \textcolor{stringliteral}{"{},"{}} << ref\_height << \textcolor{stringliteral}{"{})\(\backslash\)n"{}};}
\DoxyCodeLine{842         \}}
\DoxyCodeLine{843     \}}
\DoxyCodeLine{844 }
\DoxyCodeLine{845     \textcolor{keywordflow}{if} (verboseErrors) \{}
\DoxyCodeLine{846         std::cerr << \textcolor{stringliteral}{"{}PPMvsPPM: comparing images size ("{}} << src\_width << \textcolor{stringliteral}{"{},"{}} << src\_height}
\DoxyCodeLine{847                   << \textcolor{stringliteral}{"{}) epsilon("{}} << epsilon << \textcolor{stringliteral}{"{}), threshold("{}} << threshold * 100 << \textcolor{stringliteral}{"{}\%)\(\backslash\)n"{}};}
\DoxyCodeLine{848     \}}
\DoxyCodeLine{849 }
\DoxyCodeLine{850     \textcolor{keywordflow}{if} (compareData(ref\_data, src\_data, src\_width * src\_height * 4, epsilon, threshold) == \textcolor{keyword}{false}) \{}
\DoxyCodeLine{851         error\_count = 1;}
\DoxyCodeLine{852     \}}
\DoxyCodeLine{853 }
\DoxyCodeLine{854     \textcolor{keywordflow}{if} (error\_count == 0) \{}
\DoxyCodeLine{855         \textcolor{keywordflow}{if} (verboseErrors) \{ std::cerr << \textcolor{stringliteral}{"{}    OK\(\backslash\)n\(\backslash\)n"{}}; \}}
\DoxyCodeLine{856     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{857         \textcolor{keywordflow}{if} (verboseErrors) \{ std::cerr << \textcolor{stringliteral}{"{}    FAILURE!  "{}} << error\_count << \textcolor{stringliteral}{"{} errors...\(\backslash\)n\(\backslash\)n"{}}; \}}
\DoxyCodeLine{858     \}}
\DoxyCodeLine{859 }
\DoxyCodeLine{860     \textcolor{comment}{// returns true if all pixels pass}}
\DoxyCodeLine{861     \textcolor{keywordflow}{return} (error\_count == 0) ? true : \textcolor{keyword}{false};}
\DoxyCodeLine{862 \}}
\DoxyCodeLine{863 }
\DoxyCodeLine{864 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} sdkComparePGM(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *src\_file, \textcolor{keyword}{const} \textcolor{keywordtype}{char} *ref\_file, \textcolor{keyword}{const} \textcolor{keywordtype}{float} epsilon,}
\DoxyCodeLine{865                           \textcolor{keyword}{const} \textcolor{keywordtype}{float} threshold, \textcolor{keywordtype}{bool} verboseErrors) \{}
\DoxyCodeLine{866     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *src\_data = 0, *ref\_data = 0;}
\DoxyCodeLine{867     uint64\_t error\_count = 0;}
\DoxyCodeLine{868     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ref\_width, ref\_height;}
\DoxyCodeLine{869     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} src\_width, src\_height;}
\DoxyCodeLine{870 }
\DoxyCodeLine{871     \textcolor{keywordflow}{if} (src\_file == NULL || ref\_file == NULL) \{}
\DoxyCodeLine{872         \textcolor{keywordflow}{if} (verboseErrors) \{}
\DoxyCodeLine{873             std::cerr << \textcolor{stringliteral}{"{}PGMvsPGM: src\_file or ref\_file is NULL."{}}}
\DoxyCodeLine{874                          \textcolor{stringliteral}{"{}  Aborting comparison\(\backslash\)n"{}};}
\DoxyCodeLine{875         \}}
\DoxyCodeLine{876 }
\DoxyCodeLine{877         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{878     \}}
\DoxyCodeLine{879 }
\DoxyCodeLine{880     \textcolor{keywordflow}{if} (verboseErrors) \{}
\DoxyCodeLine{881         std::cerr << \textcolor{stringliteral}{"{}> Compare (a)rendered:  <"{}} << src\_file << \textcolor{stringliteral}{"{}>\(\backslash\)n"{}};}
\DoxyCodeLine{882         std::cerr << \textcolor{stringliteral}{"{}>         (b)reference: <"{}} << ref\_file << \textcolor{stringliteral}{"{}>\(\backslash\)n"{}};}
\DoxyCodeLine{883     \}}
\DoxyCodeLine{884 }
\DoxyCodeLine{885     \textcolor{keywordflow}{if} (sdkLoadPPMub(ref\_file, \&ref\_data, \&ref\_width, \&ref\_height) != \textcolor{keyword}{true}) \{}
\DoxyCodeLine{886         \textcolor{keywordflow}{if} (verboseErrors) \{}
\DoxyCodeLine{887             std::cerr << \textcolor{stringliteral}{"{}PGMvsPGM: unable to load ref image file: "{}} << ref\_file << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{888         \}}
\DoxyCodeLine{889 }
\DoxyCodeLine{890         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{891     \}}
\DoxyCodeLine{892 }
\DoxyCodeLine{893     \textcolor{keywordflow}{if} (sdkLoadPPMub(src\_file, \&src\_data, \&src\_width, \&src\_height) != \textcolor{keyword}{true}) \{}
\DoxyCodeLine{894         std::cerr << \textcolor{stringliteral}{"{}PGMvsPGM: unable to load src image file: "{}} << src\_file << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{895         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{896     \}}
\DoxyCodeLine{897 }
\DoxyCodeLine{898     \textcolor{keywordflow}{if} (src\_height != ref\_height || src\_width != ref\_width) \{}
\DoxyCodeLine{899         \textcolor{keywordflow}{if} (verboseErrors) \{}
\DoxyCodeLine{900             std::cerr << \textcolor{stringliteral}{"{}PGMvsPGM: source and ref size mismatch ("{}} << src\_width << \textcolor{stringliteral}{"{},"{}}}
\DoxyCodeLine{901                       << src\_height << \textcolor{stringliteral}{"{})vs("{}} << ref\_width << \textcolor{stringliteral}{"{},"{}} << ref\_height << \textcolor{stringliteral}{"{})\(\backslash\)n"{}};}
\DoxyCodeLine{902         \}}
\DoxyCodeLine{903     \}}
\DoxyCodeLine{904 }
\DoxyCodeLine{905     \textcolor{keywordflow}{if} (verboseErrors)}
\DoxyCodeLine{906         std::cerr << \textcolor{stringliteral}{"{}PGMvsPGM: comparing images size ("{}} << src\_width << \textcolor{stringliteral}{"{},"{}} << src\_height}
\DoxyCodeLine{907                   << \textcolor{stringliteral}{"{}) epsilon("{}} << epsilon << \textcolor{stringliteral}{"{}), threshold("{}} << threshold * 100 << \textcolor{stringliteral}{"{}\%)\(\backslash\)n"{}};}
\DoxyCodeLine{908 }
\DoxyCodeLine{909     \textcolor{keywordflow}{if} (compareData(ref\_data, src\_data, src\_width * src\_height, epsilon, threshold) == \textcolor{keyword}{false}) \{}
\DoxyCodeLine{910         error\_count = 1;}
\DoxyCodeLine{911     \}}
\DoxyCodeLine{912 }
\DoxyCodeLine{913     \textcolor{keywordflow}{if} (error\_count == 0) \{}
\DoxyCodeLine{914         \textcolor{keywordflow}{if} (verboseErrors) \{ std::cerr << \textcolor{stringliteral}{"{}    OK\(\backslash\)n\(\backslash\)n"{}}; \}}
\DoxyCodeLine{915     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{916         \textcolor{keywordflow}{if} (verboseErrors) \{ std::cerr << \textcolor{stringliteral}{"{}    FAILURE!  "{}} << error\_count << \textcolor{stringliteral}{"{} errors...\(\backslash\)n\(\backslash\)n"{}}; \}}
\DoxyCodeLine{917     \}}
\DoxyCodeLine{918 }
\DoxyCodeLine{919     \textcolor{comment}{// returns true if all pixels pass}}
\DoxyCodeLine{920     \textcolor{keywordflow}{return} (error\_count == 0) ? true : \textcolor{keyword}{false};}
\DoxyCodeLine{921 \}}
\DoxyCodeLine{922 }
\DoxyCodeLine{923 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// COMMON\_HELPER\_IMAGE\_H\_}}

\end{DoxyCode}
